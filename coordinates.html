<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Sigit Ari Wijanarko, Hendy Irawan" />

<meta name="date" content="2015-04-05" />

<title>Lumen 2D/3D Coordinate System</title>

<script src="coordinates_files/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="coordinates_files/bootstrap-3.3.1/css/bootstrap.min.css" rel="stylesheet" />
<script src="coordinates_files/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="coordinates_files/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="coordinates_files/bootstrap-3.3.1/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="coordinates_files/highlight/default.css"
      type="text/css" />
<script src="coordinates_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div id="header">
<h1 class="title">Lumen 2D/3D Coordinate System</h1>
<h4 class="author"><em>Sigit Ari Wijanarko, Hendy Irawan</em></h4>
<h4 class="date"><em>April 05, 2015</em></h4>
</div>


<div id="metrics-unitsscale-and-3d-coordinate-systems" class="section level2">
<h2>Metrics Units/Scale and 3D Coordinate Systems</h2>
<p>Unreal Units (UU) are 1 cm, 0.01 of Blender/SecondLife. Left handed, +x forward, +y right, +z up.</p>
<p>Unity Units are by default 1 m, terbukti dari setting gravity default 9.81 (m/s) yang sesuai reality, tapi memang Unity lebih lax dalam urusan unit. Left handed, x+ right, y+ up, z+ forward.</p>
<p>Blender Units (BU) are usually 1 m. See <a href="https://wiki.unrealengine.com/Static_Mesh_from_Blender">Static Mesh from Blender</a>. Right handed but +z up: +x is to left, +y incoming, +z up. From Blender to X3D: rotate +90deg (CCW) on z axis. From X3D to Blender: rotate -90 (CW) on z axis.</p>
<ul>
<li>Dari Blender, pas export FBX, gunakan export scale 1 aja, jadi unit si model tetap meter.</li>
<li>Di Unreal, pas import FBX, gunakan import scale 0.01. Dari meter menjadi cm.</li>
<li>Di Unity, pas import FBX, gunakan import scale 1. Dari meter tetap meter.</li>
</ul>
<p><a href="http://wiki.secondlife.com/wiki/Coordinate">Second Life / OpenSimulator</a> uses meters. A sim is 256×256 (x×y) meters. x is longitude (from west to east, the wiki is partially incorrect, but the examples are good and are <a href="http://xahsl.org/sl/build_pos.html">verified here</a>), y is latitude (from south to north). z is altitude where 0 is lowest possible point. When someone is facing north, this is exactly same as Blender.</p>
<p><a href="http://osm-3d.org">OSM-3D.org</a></p>
<p>See:</p>
<ul>
<li><a href="http://koenigstuhl.geog.uni-heidelberg.de/gdi-3d/">3D Geodata Infrastructure (GDI-3D)</a>, this hosts:
<ul>
<li><a href="http://www.OSM-3D.org">OpenStreetMap-3D</a>: Combining free and user generated data from OpenStreetMap with SRTM DEM - currently for entire Germany.</li>
<li><a href="http://www.nrw-3d.de">NorthRhine-Westphalia-3D</a>: All - over 6 Million - LOD1 buildings from GeoBasis.NRW in GDI-3D</li>
<li><a href="http://www.heidelberg-3d.de">Heidelberg-3D</a>: Official data combined with textured high resolution building models of Heidelberg</li>
</ul></li>
<li><a href="http://www.w3ds.org/doku.php">Web 3D Service (W3DS)</a>, related to and mentions CityGML in the spec, menggunakan X3D spec juga.</li>
<li><a href="http://www.web3d.org/">Web3D Consortium / X3D</a> used by NASA, DoD, Intel, IBM, National Institute of Health, Toshiba… curiously Google is missing? ISO/IEC standards:
<ul>
<li><a href="http://standards.sedris.org/18026_Ed2/ISO_IEC_18026_Ed2/ISO_IEC_18026_NOTES.html">ISO/IEC 18026:2009(E) Spatial Reference Model (SRM)</a></li>
<li>ISO/IEC 18026:201x, Information technology — Spatial Reference Model (SRM) (to be published)</li>
<li>ISO/IEC 19775-2, Information technology — Computer graphics, image processing and environmental data representation — Extensible 3D (X3D) — Part 2: Scene access interface (SAI)</li>
<li>ISO/IEC 19776, Information technology — Computer graphics, image processing and environmental data representation — Extensible 3D (X3D) encodings</li>
</ul></li>
<li><a href="http://www.citygml.org/">CityGML</a></li>
<li><a href="http://wiki.openstreetmap.org/wiki/OSM2World">OSM2World</a>, bisa tagging ada pintu, kursi, dll.</li>
<li><a href="http://www.x3dom.org/">X3DOM</a></li>
</ul>
<p><a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/geometry3D.html">X3D Geometry3D</a>: facing north, means +x right, +y up, +z incoming. Same as OpenGL.</p>
<p><img src="RightHandRuleAxes.png" alt="right hand rule axes" /></p>
<p>From <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html">X3D Concepts</a>: ISO/IEC 19775 uses a Cartesian, right-handed, three-dimensional coordinate system. By default, the viewer is on the Z-axis looking north to the -Z-axis toward the origin with +X to the right/east and +Y straight up. A modelling transformation (see the Transform node definition in <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/group.html">10 Grouping component</a> and the Billboard node definition in <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/navigation.html">23 Navigation component</a>) or viewing transformation (see the X3DViewpointNode node type definition in <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/navigation.html">23 Navigation component</a> can be used to alter this default projection. <a href="http://www.web3d.org/x3d/content/examples/X3dSceneAuthoringHints.html#CoordinateSystems">X3D Scene Authoring Hints - Coordinate Systems</a>:</p>
<ul>
<li>Each Transform node can create a new relative coordinate system for all children nodes in the scene graph.
<ul>
<li>Each set of axes follows the right-hand rule (RHR) for coordinate systems.</li>
</ul></li>
<li>Angular rotations are expressed in radians, using right-hand rule (RHR) with thumb pointing along positive direction for axis of interest and the other fingers curling in the direction of positive rotation.
<ul>
<li>Each set of orientations follows the right-hand rule (RHR) for angle rotations.</li>
<li><img src="RightHandRuleOrientations.png" alt="right-hand rule rotations" /></li>
</ul></li>
<li>Local/world coordinate systems:
<ul>
<li>+X-axis is nose/East</li>
<li>+Y-axis is vertical/up</li>
<li>+Z-axis is right-hand side (RHS)/South.</li>
</ul></li>
</ul>
<p>Tapi koq SRM itu menggunakan z+up ya… ga kaya X3D yang y+up. Kayanya mending ikut X3D deh yang interoperable dan sudah banyak support.</p>
<p><img src="srm-position.png" alt="SRM Position" /></p>
<p>Koordinat <span class="math">\((0,0,0)\)</span> adalah origin (pojok southwest) dari si tile dari Tile Map Service (TMS). Maka semua koordinat scene adalah untuk X pasti positif (dari west=0 ke east), dan untuk Z pasti negatif (dari south=0 ke north).</p>
<div id="right-handed-to-left-handed" class="section level3">
<h3>Right-handed to Left-handed</h3>
<ul>
<li>Between Right-handed and Left-handed: flip an axis</li>
<li>Between Y-up and Z-up: just swap the Y and Z, retain handedness</li>
</ul>
</div>
<div id="units" class="section level3">
<h3>Units</h3>
<p>From <a href="http://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html">X3D Concepts</a>:</p>
<p>Table 4.2 lists the initial base units for ISO/IEC 19775.</p>
<p>Table 4.2 — Standard units</p>
<table>
<thead>
<tr class="header">
<th align="left">Category</th>
<th align="left">Initial base unit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">angle</td>
<td align="left">radian</td>
</tr>
<tr class="even">
<td align="left">force</td>
<td align="left">newton</td>
</tr>
<tr class="odd">
<td align="left">length</td>
<td align="left">metre</td>
</tr>
<tr class="even">
<td align="left">mass</td>
<td align="left">kilogram</td>
</tr>
</tbody>
</table>
<p>Table 4.3 — Derived units</p>
<table>
<thead>
<tr class="header">
<th align="left">Category</th>
<th align="left">Initial base unit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">acceleration</td>
<td align="left"><span class="math">\(length/second^2\)</span></td>
</tr>
<tr class="even">
<td align="left">angular_rate</td>
<td align="left"><span class="math">\(angle/second\)</span></td>
</tr>
<tr class="odd">
<td align="left">area</td>
<td align="left"><span class="math">\(length^2\)</span></td>
</tr>
<tr class="even">
<td align="left">speed</td>
<td align="left"><span class="math">\(length/second\)</span></td>
</tr>
<tr class="odd">
<td align="left">volume</td>
<td align="left"><span class="math">\(length^3\)</span></td>
</tr>
</tbody>
</table>
<p>The standard colour space used by this International Standard is RGB where each colour component has the range [0.,1.].</p>
</div>
<div id="konversi-ke-game-engine-coordinates" class="section level3">
<h3>Konversi ke Game Engine Coordinates</h3>
<p>Dalam sistem Lumen yang dipakai sebagai standar adalah sistem Second Life. Jadi pada saat image recognition/tracking, semua koordinatnya menggunakan aturan Second Life.</p>
<ul>
<li>Dari koordinat Lumen ke Unreal, pada saat visualisasi Unreal, maka swap x dan y lalu koordinatnya akan discale menjadi Unreal Units (×0.01). Sebaliknya dari Unreal ke Lumen, koordinatenya discale menjadi SecondLife/Blender units (×100) lalu swap x dan y.</li>
<li>Dari koordinat Lumen ke Unity, pada saat visualisasi Unity, maka koordinatnya akan di-rotate 90degrees for X (pitch) sehingga y+ up dan z+ away. Sebaliknya dari Unity ke Lumen, koordinatenya dirotate -90degrees for X (pitch) menjadi SecondLife/Blender coordinates (y+ away, +z up).</li>
</ul>
<p>Untuk rotasi 3D, menggunakan style Blender/SecondLife. See also: <a href="https://docs.unrealengine.com/latest/INT/API/Runtime/Core/Math/FRotator/index.html">rotation Unreal</a>. Unit sudut adalah degrees, karena sudut degrees juga dipakai oleh Unreal/Unity/Blender. Pas kalkulasi internal baru diubah ke radian. Nama sudutnya buka alpha, beta, gamma tapi yang lebih deskriptif yaitu pitch (tengadah), roll (geleng clockwise), yaw (menoleh ke kiri):</p>
<ul>
<li>Pitch (RX): Looking up and down (0=Straight Ahead, +Up, -Down).</li>
<li>Roll (RY): Rotation about axis of screen, 0=Straight, +Clockwise, -CCW.</li>
<li>Yaw (RZ): Rotating around (running in circles), 0=North, +West, -East. Kalo di Unreal: 0=East, +North, -South.</li>
</ul>
</div>
<div id="tile-map-service-tms" class="section level3">
<h3>Tile Map Service (TMS)</h3>
<p>Untuk mendapatkan scene, gunakan koordinat TMS seperti yang digunakan oleh OpenStreetMap/OSM-3D/GDI-3D. Karena ada LOD, jadi bisa ada beberapa scene untuk tempat yang sama. Ini dapat digunakan Lumen sebagai konteks, apakah ingin mengolah sebuah ruangan (LOD 14), atau mengolah sebuah kota (LOD 8). Beda LOD, maka ukuran sebuah tile juga berbeda.</p>
</div>
</div>
<div id="d-to-3d" class="section level2">
<h2>2D to 3D</h2>
<p>Secara umum formulanya seperti ini: (dari <a href="http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html">OpenCV Camera Calibration and 3D Reconstruction</a>, belum memasukkan koefisien distorsi radial dan tangential)</p>
<p><span class="math">\[s \cdot uv = s \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} =
ICM \left[\begin{array}{c|c} R &amp; t \end{array}\right] xyz =
\begin{bmatrix} f_x &amp; 0 &amp; c_x \\ 0 &amp; -f_y &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
\large{\left[\begin{array}{c|c} R &amp; \mathbf{t} \end{array}\right]}
\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}
\]</span></p>
<ul>
<li>ICM : intrinsic camera matrix</li>
<li><span class="math">\([R|t]\)</span> = ECM = VM : extrinsic camera matrix = view matrix. How the <em>world</em> is transformed <em>relative to the camera</em>.</li>
<li><span class="math">\(-f_y\)</span> dibikin minus agar sesuai koordinat 2D image (u+ kanan, v+ bawah)</li>
</ul>
<p>Artinya untuk sebuah point 3D <span class="math">\((x,y,z)\)</span> di <em>world coordinates</em> menjadi <em>image coordinates</em> ada 3 step pemrosesan: (penjelasan kerennya ada di <a href="http://ksimek.github.io/2012/08/22/extrinsic/">Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix</a>)</p>
<ol style="list-style-type: decimal">
<li><span class="math">\(\mathbf{t}\)</span>. Translasi dari world position menjadi camera-relative position. Setelah step ini koordinat <span class="math">\((0,0,0)\)</span> berarti posisi camera.</li>
<li><span class="math">\(R\)</span>. Rotasi. Setelah step ini maka right vector <span class="math">\((1,0,0)\)</span>, forward vector <span class="math">\((0,1,0)\)</span>, dan up vector <span class="math">\((0,0,1)\)</span>. Dengan kata lain titik 3D yang berada pada posisi tersebut persis di kanan, depan, dan atas kamera. Setelah step ini semua point berada pada <em>camera coordinates</em>. Ini setara dengan normalized camera dengan focal length 1 (meter) = <span class="math">\((f_x, f_y) = (1, 1)\)</span> dan <span class="math">\((c_x, c_y) = (0, 0)\)</span>.</li>
<li><span class="math">\(ICM\)</span>. Transformasi dari camera position menjadi perspective. Hasilnya adalah <span class="math">\((s \cdot u, s \cdot v, s)\)</span>, lalu tinggal dibagi <span class="math">\(s\)</span> untuk mendapatkan <span class="math">\(u\)</span> dan <span class="math">\(v\)</span> yaitu <em>image coordinates</em>.</li>
</ol>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
